% rubber: module pdftex

\documentclass[a4paper,11pt]{article}
\usepackage[top = 1.5 in, bottom = 1 in, left = 1 in, right = 1 in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{csquotes}
\usepackage[british]{babel}
\usepackage{lmodern}
\usepackage{url}
\usepackage{color}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{pdfpages}
\usepackage{amsmath}

\begin{document}
\title{Compiler project: MiniJava}
\author{Laura Lepp√§nen \\ Compilers, Spring 2012}
\date{\today}
\maketitle
\thispagestyle{empty}

\tableofcontents
\onehalfspacing

\newpage
\setcounter{page}{1}

\section{The Mini-Java language}

\subsection{Token patterns}

Defined using regular expressions with Java style character classes. These token groups correspond to token classes used in the implementation.

\begin{description}
\item[Identifiers] $\backslash\text{p\{IsAlphabetic\}} [ \backslash\text{p\{IsAlphabetic\}}\backslash\text{p\{IsDigit\}\_ } ]^{*}$ \\ \emph{Except simple types and keywords.}
\item[Integer literals] $\backslash\text{p\{IsDigit\}}^{+}$
\item[Simple type] int | boolean | void
\item[Keyword] class | public | static | main | extends | assert | if | else | \\ while | System | out | println | return | new | length | this | true | false
\item[Operator] \&\& | || | < | > | == | + | - | *  | / | \% | = | !
\item[Punctuation] \{ | \} | [ | ] | ( | ) | $\backslash$. | ; | ,
\end{description}

\subsection{Modified grammar for recursive descent parsing (non-LL(1))}

In the grammar below, I have solved operator precedences using the ``classical'' method of making a separate production rule for each level of operator precedence. This is very easy to implement in the case of Mini-Java especially since all the defined binary operators are left-associative and there is only one unary operator. In a more complex case something like the Shunting Yard algorithm would probably work better.\footnote{Note: A program example on the course's grammar page also uses a unary minus operator, but this is not reflected in the grammar that was given, so I have left it out.}

A look-ahead of more than one token is needed e.g. when the parser sees an identifier in the input and is trying to parse a statement. In this case the result could be a local variable declaration for either a user defined type or an array of a user defined type or a statement that starts with an expression that begins with a variable reference.

\begin{verbatim}
<program>              ::= <main class> <class declaration list>
<main class>           ::= "class" <identifier> "{" "public" "static" "void" "main"
                           "(" ")" "{" <statement list> "}" "}"
<class declaration>    ::= "class" <identifier> <optional inheritance> "{"
                           <declaration list> "}"
<optional inheritance> ::= "extends" <identifier>
                        |  epsilon
<declaration>          ::= <variable declaration>
                        |  <method declaration>

<class declaration list> ::= <class declaration> <class declaration list>
                          |  epsilon
<declaration list>       ::= <declaration> <declaration list>
                          |  epsilon
<statement list>         ::= <statement> <statement list>
                          |  epsilon

<method declaration>   ::= "public" <type> <identifier> "(" <opt formals> ")"
                           "{" <statement list> "}"
<opt formals>          ::= <type> <identifier> <formals list>
                        |  epsilon
<formals list>         ::= "," <type> <identifier> <formals list>
                        |  epsilon
<variable declaration> ::= <type> <identifier> ";"
<type>                 ::= <simple type> <opt brackets>
<simple type>          ::= "int" | "boolean" | "void" | <type identifier>
<opt brackets>         ::= "[" "]" | epsilon
<type identifier>      ::= <identifier>

<statement>      ::= "assert" "(" <expr> ")" ";"
                  |  <local variable declaration>
                  |  "{" <statement list> "}"
                  |  "if" "(" <expr> ")" <statement> <opt else>
                  |  "while" "(" <expr> ")" <statement>
                  |  "System" "." "out" "." "println" "(" <expr> ")" ";"
                  |  "return" <expr> ";"
                  |  <expr> <opt assignment> ";"
<opt else>       ::= "else" <statement> | epsilon
<opt assignment> ::= "=" <expr> | epsilon
<local variable declaration> ::= <variable declaration>

<expr> ::= <or-operand> <or-operand-list>
<or-operand> ::= <and-operand> <and-operand-list>
<and-operand> ::= <eq-operand> <eq-operand-list>
<eq-operand>  ::= <neq-operand> <neq-operand-list>
<neq-operand> ::= <add-operand> <add-operand-list>
<add-operand> ::= <mult-operand> <mult-operand-list>
<mult-operand> ::= "!" <term>
                |  <term>

<or-operand-list> ::= "||" <or-operand> <or-operand-list>
                   |  epsilon
<and-operand-list> ::= "&&" <and-operand> <and-operand-list>
                    |  epsilon
<eq-operand-list> ::= "==" <eq-operand> <eq-operand-list>
                   |  epsilon
<neq-operand-list> ::= "<" <neq-operand> <neq-operand-list>
                    |  ">" <neq-operand> <neq-operand-list>
                    |  epsilon
<add-operand-list> ::= "+" <add-operand> <add-operand-list>
                    |  "-" <add-operand> <add-operand-list>
                    |  epsilon
<mult-operand-list> ::= "/" <mult-operand> <mult-operand-list>
                     |  "*" <mult-operand> <mult-operand-list>
                     |  "%" <mult-operand> <mult-operand-list>
                     |  epsilon

<term>    ::= "new" <new type> <opt term tail>
           |  "(" <expr> ")" <opt term tail>
           |  <identifier> <opt term tail>
           |  <integer literal> <opt term tail>
           |  "this" <opt term tail>
           |  "true" <opt term tail>
           |  "false" <opt term tail>

<new type>          ::= <simple type> "[" <expr> "]"
                     |  <type identifier> "(" ")"
<opt term tail>     ::= "[" <expr> "]" <opt term tail>
                     |  "." <method invocation> <opt term tail>
                     |  epsilon
<method invocation> ::= "length"
                     |  <identifier> "(" <opt exprs> ")"
<opt exprs>         ::= <expr list> | epsilon
<expr list>         ::= <expr> <expr list tail>
<expr list tail>    ::= "," <expr list> | epsilon

\end{verbatim}

\subsection{Abstract syntax trees}

In this section I describe on an abstract level the interfaces and classes implementing the abstract syntax tree representation and their relationships in the syntax tree.

\subsubsection{An example tree}

The following figure is a partial example of an abstract syntax tree for the sample program with the unary minus eliminated.

\begin{verbatim}
class Factorial {
  public static void main () {
    System.out.println (new Fac ().ComputeFac (10));
  }
}
class Fac {
  public int ComputeFac (int num) {
    assert (num > 0 || num == 0);
    int num_aux;
    if (num == 0)
      num_aux = 1;
    else 
      num_aux = num * this.ComputeFac (num-1);
    return num_aux;
  }
}
\end{verbatim}

\includegraphics[width=1.0\textwidth]{ast.pdf}

\subsubsection{Interfaces}
\begin{description}
\item[ISyntaxTreeNode] \emph{is a node that can be visited.}
\item[IStatement] \emph{is an} ISyntaxTreeNode \emph{and represents a Mini-Java statement}
\item[IExpression] \emph{is an} ISyntaxTreeNode \emph{and represents a Mini-Java expression}
\end{description}

\subsubsection{Interface implementers}
\begin{description}
\item[Program] \emph{is an} ISyntaxTreeNode \\
\emph{is a root node.} \\
\emph{has a} \textbf{MainClassDeclaration} \\
\emph{has many} \textbf{ClassDeclaration}s
\\
\item[SyntaxElement] \emph{is an abstract} ISyntaxTreeNode \\
\emph{stores row and column information for nodes.}
\\
\item[MainClassDeclaration] \emph{is a} SyntaxElement \\
\emph{has a} \textbf{MethodDeclaration} \emph{which is the main method.} \\
\emph{defines a scope in the semantic analysis phase.}
\item[ClassDeclaration] \emph{is a} SyntaxElement \\
\emph{has many} \textbf{Declaration}s \\
\emph{defines a scope in the semantic analysis phase.}
\\
\item[Declaration] \emph{is an abstract} SyntaxElement \\
\emph{stores type information.}
\item[MethodDeclaration] \emph{is a} Declaration \\
\emph{has many} \textbf{VariableDeclaration}s \emph{which represent formal parameters.} \\
\emph{has many} \textbf{IStatement}s \emph{which form the method body.} \\
\emph{defines a scope in the semantic analysis phase.}
\item[VariableDeclaration] \emph{is a} Declaration \emph{and an} IStatement
\\
\item[AssertStatement] \emph{is a} SyntaxElement \emph{and an} IStatement \\
\emph{has an} \textbf{IExpression} \emph{which is the boolean argument.}
\item[BlockStatement] \emph{is a} SyntaxElement \emph{and an IStatement} \\
\emph{has many} \textbf{IStatement}s \emph{which form the body of the block.} \\
\emph{defines a scope in the semantic analysis phase.}
\item[IfStatement] \emph{is a} SyntaxElement \emph{and an} IStatement \\
\emph{has an} \textbf{IExpression} \emph{which represents the condition.} \\
\emph{has a} \textbf{BlockStatement} \emph{which is the then branch.} \\
\emph{has optionally a} \textbf{BlockStatement} \emph{which is the else branch.}
\item[WhileStatement] \emph{is a} SyntaxElement \emph{and an} IStatement \\
\emph{has an} \textbf{IExpression} \emph{which represents the condition.} \\
\emph{has a} \textbf{BlockStatement} \emph{which is the loop body}
\item[PrintStatement] \emph{is a} SyntaxElement \emph{and an} IStatement \\
\emph{has an} \textbf{IExpression} \emph{which is the integer argument.}
\item[ReturnStatement] \emph{is a} SyntaxElement \emph{and an} IStatement \\
\emph{has an} \textbf{IExpression} \emph{which is the expression to return.}
\item[MethodInvocation] \emph{is a} SyntaxElement \emph{and an} IStatement \emph{and an} IExpression \\
\emph{has an} \textbf{IExpression} \emph{which is the method owner} \\
\emph{has many} \textbf{IExpression}s \emph{which are the call parameters.}
\\
\item[ArrayIndexingExpression] \emph{is a} SyntaxElement \emph{and an} IExpression \\
\emph{has an} \textbf{IExpression} \emph{which is the array reference.} \\
\emph{has an} \textbf{IExpression} \emph{which is the index.}
\item[InstanceCreationExpression] \emph{is a} SyntaxElement \emph{and an} IExpression \\
\emph{has optionally an} \textbf{IExpression} \emph{which is the array size if this is an array creation.} \\
\emph{represents the 'new' expression.}
\item[ThisExpression] \emph{is a} SyntaxElement \emph{and an} IExpression \\
\emph{represents the reference to 'this' class.}
\item[VariableReferenceExpression] \emph{is a} SyntaxElement \emph{and an} IExpression
\item[UnaryOperatorExpression] \emph{is a} SyntaxElement \emph{and an} IExpression \\
\emph{has an} \textbf{IExpression} \emph{which is the operand.}
\item[BinaryOperatorExpression] \emph{is a} SyntaxElement \emph{and an} IExpression \\
\emph{has an} \textbf{IExpression} \emph{that is the left operand.} \\
\emph{has an} \textbf{IExpression} \emph{that is the right operand.}
\item[BooleanLiteralExpression] \emph{is a} SyntaxElement \emph{and an} IExpression
\item[IntegerLiteralExpression] \emph{is a} SyntaxElement \emph{and an} IExpression
\end{description}

\section{Compiler implementation}

This section covers the general architecture of the compiler, testing, error handling as well as the building and running instuctions.

\subsection{Architecture}

The front-end module is divided into three sub-modules, one for each major phase of compilation: lexical analysis, syntax analysis and semantic analysis. In addition, I have collected some things possibly needed by both the front-end and the back-end into the Support module. These include:
\begin{itemize}
\item The abstract syntax tree representation and the related INodeVisitor interface.
\item The symbol table.
\item Static information on the language such as listings of keywords, punctuation characters, operators and operator semantics, precedences etc. This can be expanded to include possible semantic information needed by the back-end later.
\item Error handling: an error reporter interface and a basic implementation for it.
\end{itemize}

\subsubsection{Simplified view of the front-end module}

The FrontEnd class implements the whole front-end compilation pipeline with the help of the aforementioned sub-modules that implement the different phases of compilation. These submodules are descibed starting in the next section.

The idea is to have a separate back-end module that will also have a single class that is parameterised with the output of the front-end phases to bring together the whole back-end pipeline. The whole compiler can then be put together by running these two modules on the program code in succession.

\includegraphics[width=1.0\textwidth]{frontend.pdf}

\subsubsection{Simplified view of the support module}

\includegraphics[width=1.0\textwidth]{support.pdf}

\subsection{Lexical analysis}

\subsubsection{Module description}

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth]{lexical_analysis.pdf}
\end{figure}

The MiniJavaScanner can read input from either a string or a file: it is parameterised with a TextReader (either a StringReader or a StreamReader) for the program code. It offers a very simple interface: it can be asked for the next token in the input stream. At the end of input, a call to NextToken returns an EndOfFile token. If NextToken is still called after that, an OutOfInput exception will be thrown.

The MiniJavaScanner passes through the code once when instantiated and builds the queue of tokens. This is done so no one can close the TextReader before the whole token stream is ready. The scanner leaves the TextReader open because it is given as a parameter, so it could in theory still be used by the caller.

Internally, the MiniJavaScanner uses a ScannerInputReader to keep track of the current row and column in the input (for error messages), and skip comments and whitespace. This abstracts away all input handling, so the scanner itself stays cleaner and could easily be replaced by another class that would implement the ITokenizer interface.

\subsubsection{Error handling}

The scanner can identify two distinct types of errors:
\begin{enumerate}
\item a multiline comment ended by end of input and
\item an unrecognised token such as characters '\$', '\#' or '@'.
\end{enumerate}

These errors are represented by ErrorToken instances in the token queue. Unlike all other phases of the compiler, the scanner does not throw an exception if it encounters errors like these. The handling of ErrorTokens is left to the caller or the next phase in the pipeline. In practice these errors are handled in the syntax analysis phase.

\subsection{Syntax analysis}

\subsubsection{Module description}

\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{syntax_analysis.pdf}
\end{figure}

This module is used by instantiating a Parser that takes an ITokenizer an an IErrorReporter as inputs. The error reporter is used to report errors and because it is given as a parameter, a single instance can be shared by several classes and across compilation phases. The default implementation ErrorReporter logs the errors in a list of ErrorMessages which can then be handled by the higher level module that has access to the reporter instance. A custom implementation could e.g. print error messages into standard output in real time when they are reported.

The Parser offers a Parse() method that either returns a Program node (the root of the abstract syntax tree) or throws a CompilationFailed exception. In the latter case the list of errors can be accessed through the error reporter. This is the whole interface needed by the caller.

Internally the parser is split into several parts. The main parser creates a new ExpressionParser instance every time it starts parsing an expression. The ExpressionParser takes care of handling e.g. operator precedences using information provided by the MiniJavaInfo support class. This takes some unnecessary complexity out of the main parser class. In theory, the parser could be further split up into e.g. statement and class parsers.

Additionally, there are two list parsers: a generic ListParser that parses nodes with the function parameter until it encounters the end of file or a specified follow set token and a CommaSeparatedListParser that does the same but expects the list to use commas as separators. These are used to parse e.g. parameter and argument lists (comma separated) and lists of classes, statements and declarations.

The parser uses a ParserInputReader (or IParserInputReader) that abstracts away input buffering, peeking (even several steps ahead) and matching tokens to a certain token type and possibly content. The parser can e.g. ask the input reader to check that the next token is a PunctuationToken that has the lexeme '\{', and if so, consume it, cast it to the right type and return it. The Consume method of the ParserInputReader is used every time a token is consumed. If the token consumed is an ErrorToken, the ParserInputReader uses the IErrorReporter to report the error and also informs the actual parser by throwing an appropriate exception. This way all lexical errors get reported.

\subsubsection{Error handling}

The syntax analysis phase can encounter two types of errors:
\begin{enumerate}
\item lexical errors in the form of ErrorTokens from the ITokenizer token queue
\item syntax errors: a token other than what was expected is encountered.
\end{enumerate}

Both types of errors are reported using the IErrorReporter. When an error is encountered, the parser attempts recovery based on reading tokens until one in the follow set is encountered or the end of file is reached. This does not always work terribly well. E.g. if a semicolon is missing from a statement, the recovery routine tries to parse until the next semicolon, because parsing failed while a statement was being parsed. If that statement was the last one in that class, the recovery can end up in the next class.

Expression recovery is especially problematic since the follow set for expressions is large. Some of these problems could possibly be avoided by careful parameterisation of the recovery routines depending on the exact place where a parse error happened but this would make the parser quite a bit more complex and I am not sure whether the exception based error handling used in the current implementation is entirely compatible with these kinds of strategies.

For many common kinds of syntax errors this basic strategy works fine but some pathological cases can cause a stream of uninformative errors following the one actual error\footnote{Examples with explanations can be found in the recovery test code.}. A peculiarity is that often recovery causes an end of input error to be reported twice albeit with two different messages. This is because some methods need to check the type of the input token before choosing the parsing path to take. In this case they can see that the token in the input is an EndOfFile token before any matching is attempted. After this the parser goes into recovery, as is normal when an error is found, and receives an OutOfInput error from the ITokenizer, which causes another reporting of the end of input error.

This peculiarity could easily be fixed by not letting the parsing methods report the error themselves but I have kept this ``feature'' because it produces a bit of useful extra information in some cases.

If no errors are found, parsing ends with the EndOfFile token being consumed and the Program node is returned. If any errors (lexical or syntactic) have been found, a CompilationFailed exception is thrown to be handled by the caller.

\subsection{Semantic analysis}

% error handling in this phase

\subsection{Testing}

\subsection{Building and running the compiler}

\subsection{Possible bugs}

\end{document}
